<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Ti·∫øn L√™n Mi·ªÅn Nam P2P PRO</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Oswald:wght@700&display=swap');
        body { background: #020617; touch-action: manipulation; overflow: hidden; font-family: sans-serif; }
        .poker-table {
            background: radial-gradient(circle, #14532d 0%, #064e3b 100%);
            border: 8px solid #451a03;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.7);
        }
        .card {
            width: 55px; height: 80px;
            background: white; border-radius: 6px;
            transition: all 0.2s ease; position: relative;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.5);
            user-select: none;
        }
        @media (min-width: 768px) { .card { width: 85px; height: 120px; } }
        .card.selected { transform: translateY(-25px); border: 3px solid #fbbf24; }
        .card-red { color: #ef4444; }
        .card-black { color: #1f2937; }
        .turn-highlight { border: 4px solid #fbbf24; box-shadow: 0 0 20px #fbbf24; }
        #msg-overlay { pointer-events: none; text-shadow: 2px 2px 10px rgba(0,0,0,0.8); z-index: 100; }
    </style>
</head>
<body class="flex items-center justify-center h-screen w-screen m-0 p-0 text-white">

<!-- Lobby UI -->
<div id="lobby" class="fixed inset-0 z-[200] bg-slate-900 flex flex-col items-center justify-center p-6 text-center">
    <h1 class="text-5xl font-black text-yellow-500 mb-2 italic tracking-tighter" style="font-family: 'Oswald';">TI·∫æN L√äN P2P</h1>
    <p class="text-gray-400 mb-8">Professional Web Game Developer Edition</p>
    
    <div id="connection-status" class="mb-4 text-blue-400 text-sm italic font-mono">ƒêang kh·ªüi t·∫°o h·ªá th·ªëng...</div>
    
    <div id="lobby-main" class="hidden space-y-4 w-full max-w-sm">
        <div class="bg-slate-800 p-4 rounded-2xl border border-slate-700 shadow-2xl">
            <p class="text-xs text-gray-400 mb-1 uppercase tracking-widest">ID c·ªßa b·∫°n</p>
            <div id="my-id-display" class="text-2xl font-mono font-bold text-yellow-400 select-all cursor-pointer">----</div>
        </div>
        
        <button onclick="net.startSolo()" class="w-full bg-emerald-600 hover:bg-emerald-500 py-4 rounded-2xl font-bold text-xl shadow-lg border-b-4 border-emerald-800">CH∆†I V·ªöI BOT</button>
        
        <div class="relative group">
            <input id="join-id-input" type="text" placeholder="Nh·∫≠p ID Host ƒë·ªÉ v√†o..." class="w-full px-5 py-4 bg-slate-700 rounded-2xl outline-none focus:ring-2 ring-yellow-500 text-white font-mono">
            <button onclick="net.joinGame()" class="absolute right-2 top-2 bottom-2 bg-blue-600 hover:bg-blue-500 px-6 rounded-xl font-bold">V√ÄO</button>
        </div>
    </div>
</div>

<!-- Game Board -->
<div id="game-ui" class="relative w-full h-full poker-table flex flex-col items-center justify-between py-4 hidden">
    
    <!-- Top (Player 2 / Bot 2) -->
    <div id="player-2" class="flex flex-col items-center">
        <div class="avatar w-12 h-12 md:w-16 md:h-16 rounded-full bg-slate-800 border-2 border-white flex items-center justify-center text-2xl shadow-xl">ü§ñ</div>
        <div class="info bg-black/50 px-3 py-1 rounded-full text-xs mt-1">Bot 2 (<span class="card-count">13</span>)</div>
    </div>

    <!-- Middle (Opponents Left & Right) -->
    <div class="w-full flex justify-between px-2 md:px-10">
        <div id="player-1" class="flex flex-col items-center -rotate-90 md:rotate-0">
            <div class="avatar w-12 h-12 md:w-16 md:h-16 rounded-full bg-slate-800 border-2 border-white flex items-center justify-center text-2xl shadow-xl">üë§</div>
            <div class="info bg-black/50 px-3 py-1 rounded-full text-xs mt-1">P1 (<span class="card-count">13</span>)</div>
        </div>
        
        <!-- Center Table -->
        <div id="table-center" class="flex items-center justify-center -space-x-8 md:-space-x-12 transition-all duration-500">
            <!-- Played cards go here -->
        </div>

        <div id="player-3" class="flex flex-col items-center rotate-90 md:rotate-0">
            <div class="avatar w-12 h-12 md:w-16 md:h-16 rounded-full bg-slate-800 border-2 border-white flex items-center justify-center text-2xl shadow-xl">ü§ñ</div>
            <div class="info bg-black/50 px-3 py-1 rounded-full text-xs mt-1">Bot 3 (<span class="card-count">13</span>)</div>
        </div>
    </div>

    <!-- Bottom (You) -->
    <div id="player-0" class="w-full flex flex-col items-center">
        <div id="my-hand" class="flex justify-center -space-x-8 md:-space-x-12 mb-20 md:mb-24 h-24"></div>
        <div class="flex gap-2 md:gap-4 fixed bottom-6 scale-90 md:scale-110">
            <button onclick="game.handleSkip()" class="px-6 py-2 bg-red-600 rounded-full font-bold border-b-4 border-red-800">B·ªé L∆Ø·ª¢T</button>
            <button onclick="game.handlePlay()" class="px-10 py-2 bg-yellow-500 text-black rounded-full font-black border-b-4 border-yellow-700">ƒê√ÅNH</button>
            <button onclick="game.sortHand()" class="px-6 py-2 bg-blue-600 rounded-full font-bold border-b-4 border-blue-800">X·∫æP B√ÄI</button>
        </div>
    </div>

    <div id="msg-overlay" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-5xl md:text-7xl font-black text-yellow-400 italic uppercase opacity-0 transition-all duration-300 scale-50"></div>
</div>

<script>
/** ENGINE & RULES **/
const RANKS = ['3','4','5','6','7','8','9','10','J','Q','K','A','2'];
const SUITS = ['‚ô†', '‚ô£', '‚ô¶', '‚ô•'];
const COLORS = ['card-black', 'card-black', 'card-red', 'card-red'];

class Card {
    constructor(r, s) {
        this.r = r; this.s = s;
        this.w = r * 4 + s; // weight
        this.name = RANKS[r];
        this.icon = SUITS[s];
        this.color = COLORS[s];
        this.id = `${r}-${s}`;
    }
}

class GameEngine {
    constructor() {
        this.hands = [[],[],[],[]];
        this.turn = 0;
        this.lastMove = null;
        this.lastMover = null;
        this.skipped = [false, false, false, false];
        this.selectedIds = new Set();
        this.isHost = true;
        this.myIdx = 0; // Local player index
    }

    initGame(customDeck = null) {
        let deck = customDeck || this.createDeck();
        if (this.isHost && !customDeck) {
            this.hands = [
                deck.slice(0, 13).sort((a,b)=>a.w - b.w),
                deck.slice(13, 26).sort((a,b)=>a.w - b.w),
                deck.slice(26, 39).sort((a,b)=>a.w - b.w),
                deck.slice(39, 52).sort((a,b)=>a.w - b.w)
            ];
            if (net.conn) net.sendData({ type: 'START', hands: this.hands });
        }
        
        this.checkToiTrangAll();
        this.render();
    }

    createDeck() {
        let d = [];
        for(let r=0; r<13; r++) for(let s=0; s<4; s++) d.push(new Card(r, s));
        return d.sort(() => Math.random() - 0.5);
    }

    checkToiTrangAll() {
        this.hands.forEach((hand, idx) => {
            const result = this.checkToiTrang(hand);
            if (result) {
                this.showMsg(`P${idx} T·ªöI TR·∫ÆNG: ${result}`);
                setTimeout(() => location.reload(), 5000);
            }
        });
    }

    checkToiTrang(hand) {
        const rCount = Array(13).fill(0);
        hand.forEach(c => rCount[c.r]++);
        
        // S·∫£nh r·ªìng
        let isDragon = true;
        for(let i=0; i<13; i++) if(rCount[i] === 0) isDragon = false;
        if(isDragon) return "S·∫¢NH R·ªíNG";

        // T·ª© qu√Ω heo
        if(rCount[12] === 4) return "T·ª® QU√ù HEO";

        // 6 ƒë√¥i
        let pairs = 0;
        rCount.forEach(c => { if(c >= 2) pairs += Math.floor(c/2); });
        if(pairs >= 6) return "6 ƒê√îI";

        // 5 ƒë√¥i th√¥ng
        let consecutive = 0, maxConsecutive = 0;
        for(let i=0; i<13; i++) {
            if(rCount[i] >= 2) { consecutive++; maxConsecutive = Math.max(maxConsecutive, consecutive); }
            else consecutive = 0;
        }
        if(maxConsecutive >= 5) return "5 ƒê√îI TH√îNG";

        return null;
    }

    render() {
        // Render My Hand
        const handDiv = document.getElementById('my-hand');
        handDiv.innerHTML = '';
        this.hands[this.myIdx].forEach(c => {
            const el = document.createElement('div');
            el.className = `card flex flex-col p-1 md:p-2 font-bold ${c.color} ${this.selectedIds.has(c.id) ? 'selected' : ''}`;
            el.innerHTML = `<span class="text-lg md:text-2xl leading-none">${c.name}</span><span class="text-2xl md:text-4xl">${c.icon}</span>`;
            el.onclick = () => {
                if (this.turn !== this.myIdx) return;
                this.selectedIds.has(c.id) ? this.selectedIds.delete(c.id) : this.selectedIds.add(c.id);
                this.render();
            };
            handDiv.appendChild(el);
        });

        // Render Opponents
        for(let i=0; i<4; i++) {
            const pEl = document.getElementById(`player-${i}`);
            if(!pEl) continue;
            pEl.querySelector('.card-count').innerText = this.hands[i].length;
            const avatar = pEl.querySelector('.avatar');
            this.turn === i ? avatar.classList.add('turn-highlight') : avatar.classList.remove('turn-highlight');
        }
    }

    handlePlay() {
        if(this.turn !== this.myIdx) return;
        const selected = this.hands[this.myIdx].filter(c => this.selectedIds.has(c.id));
        const moveType = this.validateMove(selected);

        if(moveType) {
            const moveData = { type: 'MOVE', pIdx: this.myIdx, cards: selected, moveType: moveType };
            this.processMove(moveData);
            if(net.conn) net.sendData(moveData);
            this.selectedIds.clear();
        } else {
            this.showMsg("B√ÄI KH√îNG H·ª¢P L·ªÜ");
        }
    }

    processMove(data) {
        const { pIdx, cards, moveType } = data;
        this.hands[pIdx] = this.hands[pIdx].filter(hc => !cards.find(cc => cc.id === hc.id));
        this.lastMove = { type: moveType, cards: cards, power: cards[cards.length-1].w };
        this.lastMover = pIdx;
        this.renderTable(cards);
        
        if(this.hands[pIdx].length === 0) {
            this.showMsg(`P${pIdx} TH·∫ÆNG CU·ªòC!`);
            return;
        }
        this.nextTurn();
    }

    handleSkip() {
        if(this.turn !== this.myIdx || !this.lastMove) return;
        const skipData = { type: 'SKIP', pIdx: this.myIdx };
        this.processSkip(skipData);
        if(net.conn) net.sendData(skipData);
    }

    processSkip(data) {
        this.skipped[data.pIdx] = true;
        this.showMsg(`P${data.pIdx} B·ªé L∆Ø·ª¢T`);
        this.nextTurn();
    }

    nextTurn() {
        this.turn = (this.turn + 1) % 4;
        const activeCount = this.skipped.filter(s => !s).length;

        if (activeCount === 1 && !this.skipped[this.turn]) {
            this.skipped = [false, false, false, false];
            this.lastMove = null;
            this.showMsg("V√íNG M·ªöI");
        } else if (this.skipped[this.turn]) {
            this.nextTurn();
            return;
        }

        this.render();
        // Bot auto play if it's bot turn AND we are Host
        if (this.isHost && (this.turn === 2 || this.turn === 3 || (this.turn === 1 && !net.conn))) {
            setTimeout(() => this.botPlay(), 1000);
        }
    }

    botPlay() {
        const hand = this.hands[this.turn];
        let cardsToPlay = null;
        let mType = null;

        if (!this.lastMove) {
            cardsToPlay = [hand[0]]; // ƒê√°nh l√° b√© nh·∫•t
            mType = 'single';
        } else if (this.lastMove.type === 'single') {
            const bigger = hand.find(c => c.w > this.lastMove.power);
            if (bigger) { cardsToPlay = [bigger]; mType = 'single'; }
        }

        if (cardsToPlay) {
            const data = { type: 'MOVE', pIdx: this.turn, cards: cardsToPlay, moveType: mType };
            this.processMove(data);
            if(net.conn) net.sendData(data);
        } else {
            const data = { type: 'SKIP', pIdx: this.turn };
            this.processSkip(data);
            if(net.conn) net.sendData(data);
        }
    }

    validateMove(cards) {
        if (cards.length === 0) return null;
        const len = cards.length;
        const sorted = [...cards].sort((a,b) => a.w - b.w);
        const power = sorted[len-1].w;

        if (!this.lastMove) {
            if (len === 1) return 'single';
            if (len === 2 && sorted[0].r === sorted[1].r) return 'pair';
            return null;
        }

        if (this.lastMove.type === 'single' && len === 1 && power > this.lastMove.power) return 'single';
        if (this.lastMove.type === 'pair' && len === 2 && sorted[0].r === sorted[1].r && power > this.lastMove.power) return 'pair';

        return null;
    }

    renderTable(cards) {
        const center = document.getElementById('table-center');
        center.innerHTML = '';
        cards.forEach(c => {
            const el = document.createElement('div');
            el.className = `card flex flex-col p-1 md:p-2 font-bold shadow-2xl ${c.color}`;
            el.innerHTML = `<span class="text-lg md:text-2xl leading-none">${c.name}</span><span class="text-2xl md:text-4xl">${c.icon}</span>`;
            center.appendChild(el);
        });
    }

    showMsg(txt) {
        const el = document.getElementById('msg-overlay');
        el.innerText = txt;
        el.classList.remove('opacity-0', 'scale-50');
        el.classList.add('opacity-100', 'scale-100');
        setTimeout(() => {
            el.classList.add('opacity-0', 'scale-50');
            el.classList.remove('opacity-100', 'scale-100');
        }, 1500);
    }

    sortHand() {
        this.hands[this.myIdx].sort((a,b) => a.w - b.w);
        this.render();
    }
}

/** NETWORK MANAGER **/
class NetworkManager {
    constructor() {
        this.peer = new Peer();
        this.conn = null;
        this.init();
    }

    init() {
        this.peer.on('open', id => {
            document.getElementById('my-id-display').innerText = id;
            document.getElementById('connection-status').innerText = "H·ªá th·ªëng s·∫µn s√†ng";
            document.getElementById('lobby-main').classList.remove('hidden');
        });

        // Host side
        this.peer.on('connection', c => {
            this.conn = c;
            game.isHost = true;
            game.myIdx = 0; // Host l√† P0
            this.setupListener();
            game.showMsg("B·∫†N B√à ƒê√É K·∫æT N·ªêI!");
            setTimeout(() => {
                document.getElementById('lobby').classList.add('hidden');
                document.getElementById('game-ui').classList.remove('hidden');
                game.initGame();
            }, 1000);
        });
    }

    joinGame() {
        const id = document.getElementById('join-id-input').value;
        if (!id) return;
        this.conn = this.peer.connect(id);
        game.isHost = false;
        game.myIdx = 1; // Client l√† P1
        this.setupListener();
        this.conn.on('open', () => {
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('game-ui').classList.remove('hidden');
            game.showMsg("ƒê√É V√ÄO PH√íNG!");
        });
    }

    startSolo() {
        document.getElementById('lobby').classList.add('hidden');
        document.getElementById('game-ui').classList.remove('hidden');
        game.initGame();
    }

    sendData(data) {
        if (this.conn && this.conn.open) this.conn.send(data);
    }

    setupListener() {
        this.conn.on('data', data => {
            if (data.type === 'START') {
                game.hands = data.hands;
                game.initGame(data.hands.flat()); // Sync b√†i t·ª´ Host
            } else if (data.type === 'MOVE') {
                game.processMove(data);
            } else if (data.type === 'SKIP') {
                game.processSkip(data);
            }
        });
    }
}

const game = new GameEngine();
const net = new NetworkManager();
</script>
</body>
</html>
